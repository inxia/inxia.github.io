<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0115)file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html -->
<html xmlns="http://www.w3.org/1999/xhtml" class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   
   <title>AsyncSocket文档</title>
   <style type="text/css">
      body {
          line-height: 120%
      }
      h1 {
          text-align: center;
          font-family: sans-serif;
          font-weight: bold;
          font-size: 2em;
          margin-bottom: 1.25em;
      }
      h2 {
          font-family: sans-serif;
          font-weight: bold;
          font-style: normal;
          font-size: 1.5em;
          margin: 1.75em 0px 1em 0px;
      }
      h3 {
          font-family: sans-serif;
          font-weight: bold;
          font-style: italic;
          margin: 1.75em 0px 0.75em 0px;
      }
      p {
          margin: 0px 0px 0.5em 0px;
      }
      ul {
          margin: 0px 0px 0.5em 0px;
      }
      table {
          border-collapse: collapse;
      }
      th {
          font-family: sans-serif;
          font-style: italic;
          font-weight: normal;
          vertical-align: top;
          text-align: left;
          border: 0px;
          width: 7em;
      }
      td {
          vertical-align: top;
          border: 0px;
      }
      td.Argument {
          width: 5em;
      }
      .Sample_Code {
          white-space: pre;
          background: #cccccc;
          font-family: monospace;
          margin: 0.75em 0px 0.75em 2em;
      }
      .Method_Heading {
          font-family: sans-serif;
          background: #cccccc;
          margin: 1.5em 0px 0.75em 0px;
      }
      .Function {
          white-space: nowrap;
      }
      .Class {
      }
      .Code {
          font-family: monospace;
      }
      .Constant {
          font-family: monospace;
      }
      .Filename {
          font-style: italic;
      }
      .Vocabulary_Word {
          font-style: italic;
      }
      .Argument {
          font-style: italic;
      }
   </style>
<link type="text/css" rel="stylesheet" charset="UTF-8" href="./文档_files/translateelement.css"></head>
<body style="margin: 1em 1em 1em 1em;">
	<h1 style="text-align: center;"><font><font>AsyncSocket文档</font></font></h1>
   <a name="intro"></a>
	<p><font><font>AsyncSocket是一个TCP / IP套接字的网络库，旨在有效地处理分组数据。</font><font>该库有两个文件，​​一个公共可可类。</font></font></p>
	<p><font><font>该图书馆是公共领域，最初是由达斯汀沃斯，和现在Deusty和可可社区维护。</font></font></p>
	<p><font><font class="">对于支持，请访问谷歌CocoaAsyncSocket代码页的</font></font><a href="http://code.google.com/p/cocoaasyncsocket/"><font><font class="">http://code.google.com/p/cocoaasyncsocket/</font></font></a></p>
    <a name="cont"></a>
    <h3><font><font>内容</font></font></h3>
    <ol>
        <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#intro"><font><font>介绍</font></font></a>
            <ul>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#cont"><font><font>内容</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#about"><font><font>关于AsyncSocket</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#doc"><font><font>关于本文档</font></font></a></li>
            </ul>
        </li>
        <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#basics"><font><font>套接字基础知识</font></font></a>
            <ul>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#limit"><font><font>插槽的限制</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#struct"><font><font>数据包结构</font></font></a></li>
            </ul>
        </li>
        <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#using"><font><font>使用AsyncSocket</font></font></a>
            <ul>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#owner"><font><font>插座所有权</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#deleg"><font><font>委托方法</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#conn"><font><font>接受，连接和断开</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#rw"><font><font>阅读和写作</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#parse"><font><font>解析包</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#err"><font><font>错误处理</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#thread"><font><font>线程和运行循环</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#sub"><font><font>定制AsyncSocket</font></font></a></li>
            </ul>
        </li>
        <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#ref"><font><font>AsyncSocket参考</font></font></a>
            <ul>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_alloc"><font><font>初始化和取消分配消息</font></font></a></li>
			<li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_ud"><font><font>用户数据信息</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_deleg"><font><font>代表团消息</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_conn"><font><font>连接消息</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_rw"><font><font>读取和写入信息</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_delim"><font><font>定界符消息</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_debug"><font><font>调试和自定义消息</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_delegmeth"><font><font>AsyncSocketDelegate方法</font></font></a></li>
            <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_err"><font><font>错误</font></font></a></li>
            </ul>		
        </li>
        <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#new"><font><font>API更改</font></font></a></li>
        <li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#idx"><font><font>API指数</font></font></a></li><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#idx">
    </a></ol><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#idx">

   </a><a name="about"></a>
	<h3><font><font>关于AsyncSocket</font></font></h3>
	<p><font><font class="">
		可可API提供了一些网络类，适合下载和上传图像和文件。</font><font class="">这些类支持HTML，FTP等协议，但不能与特定应用的协议中使用。</font><font>如果没有支持特定应用协议的低层次的套接字类，开发者必须自定义代码网络使用BSD或碳的功能与解决方案相结合
		 </font></font><span class="Class"><font><font>NSFileHandle</font></font></span><font><font>， 
		 </font></font><span class="Class"><font><font>NSInputStream</font></font></span><font><font>和 
		 </font></font><span class="Class"><font><font>NSOutputStream</font></font></span><font><font>。</font><font>这些函数和类不为TCP / IP网络在一个真正的可可应用进行优化，并且可能难以集成。
	</font></font></p>
	<p><font><font>
		AsyncSocket提供易于集成的“发射后不管”的网络，可以很容易为你的应用程序支持网络。</font><font>其特点包括：</font></font></p>
		<ul>
			<li><font><font>
				排队非阻塞读取和写入，可选超时。</font><font class="">你告诉AsyncSocket什么来读取或写入，并获得出路。</font><font>它会叫你当它完成。
			</font></font></li>
			<li><font><font>
				自动插座验收。</font><font>如果你告诉AsyncSocket接受连接，它会叫你用自己的每一个连接的新的实例。</font><font>你当然可以，请立即断开它们。
			</font></font></li>
			<li><font><font>
				委派支持。</font><font>错误，连接，接受，读完成，写落成，并断开所有的结果在邮件到您的委托。
			</font></font></li>
			<li><font><font>
				运行循环，而不是从基于线程的。</font><font>虽然您可以在主或工作线程使用AsyncSocket，你不会被强迫这样做。
				 </font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>将通过运行循环发送邮件给委托异步。</font><font>这些消息包括</font></font><span class="Argument"><font><font>插座</font></font></span><font><font>的说法，让您的多个实例加以区分</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>。
			</font></font></li>
			<li><font><font>
				自包含在一个类中。</font><font>不需要淤泥周围流或插座实例的集合。</font><font>该类处理这一切。
			</font></font></li>
			<li><font><font>
				支持TCP流。</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>不支持UDP或者多播套接字。
			</font></font></li>
			<li><font><font>
				基于苹果自己的</font></font><span class="Class"><font><font>CFSocket</font></font></span><font><font>和</font></font><span class="Class"><font><font>CFStream</font></font></span><font><font>碳的API。
			</font></font></li>
		</ul>

   <a name="doc"></a>
	<h3><font><font>关于本文档</font></font></h3>
	<p><font><font>本文假设读者已经有网络的广大市民的理解，以及可可和Objective-C编程的开发人员的理解。</font></font></p>

   <a name="basics"></a>
	<h2><font><font>套接字基础知识</font></font></h2>
	<p><font><font>在联网的说法，一台计算机是一</font></font><span class="Vocabulary_Word "><font><font>主机</font></font></span><font><font>为多个插座。</font><font>甲</font></font><span class="Vocabulary_Word "><font><font>插座</font></font></span><font><font>是通信信道的一端称为一个</font></font><span class="Vocabulary_Word "><font><font>网络连接</font></font></span><font><font> ; </font><font>另一端是另一插座。</font><font>从自己的观点来看，任何插座是</font></font><span class="Vocabulary_Word "><font><font>本地套接字</font></font></span><font><font>，和插座在连接的另一端是</font></font><span class="Vocabulary_Word "><font><font>远程套接字。</font></font></span></p>
	<p><font><font>要建立连接，两个插座之一，</font></font><span class="Vocabulary_Word "><font><font>连接插座</font></font></span><font><font>，必须与其他插座，</font></font><span class="Vocabulary_Word "><font><font>侦听套接字</font></font></span><font><font>，并监听套接字必须</font></font><span class="Vocabulary_Word "><font><font>接受</font></font></span><font><font>的连接。</font><font>联系监听套接字，在连接插座必须知道它的</font></font><span class="Vocabulary_Word "><font><font>套接字地址</font></font></span><font><font>。</font><font>每个插座有一个套接字地址。</font><font>的地址由两部分组成：</font></font><span class="Vocabulary_Word "><font><font>主机地址</font></font></span><font><font>和</font></font><span class="Vocabulary_Word "><font><font>端口号</font></font></span><font><font>。</font><font>主机地址是计算机的IP地址，端口号唯一地标识承载的计算机上的每个插座。</font></font></p>
	<p><font><font>一台计算机可以有多个主机地址。</font><font>这将有一个地址对为每一种可能的连接方法（</font></font><i><font><font>例如</font></font></i><font><font>，以太网卡，调制解调器，AirPort卡，VPN连接）和一对用于连接到其自身（称为“本地主机”）。</font><font>每对中的一个地址是IPv4地址，如“192.168.3.1”，而另一个是IPv6地址，如“为fe80 :: 230：65ff：FE29：aa9d”</font></font></p>
	<p><font><font>一个地址，如“www.google.com”对应于一个主机地址，但它不是一个主机地址本身。</font><font>它是一个</font></font><span class="Vocabulary_Word "><font><font>DNS地址</font></font></span><font><font>或</font></font><span class="Vocabulary_Word "><font><font>DNS名称</font></font></span><font><font>，这是由一个转换为主机地址</font></font><span class="Vocabulary_Word "><font><font>的DNS查找</font></font></span><font><font>操作。</font><font>一个</font></font><span class="Vocabulary_Word "><font><font>网址</font></font></span><font><font>，如“http://www.google.com:80”同样不是一个主机地址。</font><font>URL可以包括一个DNS名，主机地址，端口号和其他信息。</font></font></p>
	<p><font><font>在不同的主机上，甚至在同一主机上运行的应用程序，可以使用套接字与彼此通信。</font><font>看它的另一种方式，每个插座提供通信服务给它的</font></font><span class="Vocabulary_Word "><font><font>客户端应用程序</font></font></span><font><font>。</font><font>应用程序发送和接收的数据和从彼此，他们可以解释和在采取行动。</font><font>该数据是由字节，布置成所谓的基团</font></font><span class="Vocabulary_Word "><font><font>包</font></font></span><font><font>和发送，并根据所接收的</font></font><span class="Vocabulary_Word "><font><font>协议</font></font></span><font><font>随后两个应用程序。</font></font></p>
	<p><font><font>的协议建立每个数据包的结构，在何种情况下任何特定分组应该被发送，和规则来处理异常情况。</font><font>它还规定了每个客户端应用程序的角色。</font><font>在一个</font></font><span class="Vocabulary_Word "><font><font>客户-服务器体系结构</font></font></span><font><font>，有些应用程序（在</font></font><span class="Vocabulary_Word "><font><font>服务器</font></font></span><font><font>）提供使用的其他应用程序（服务</font></font><span class="Vocabulary_Word "><font><font>客户端</font></font></span><font><font>）。</font><font>在一个</font></font><span class="Vocabulary_Word "><font><font>对等体的对等体系结构</font></font></span><font><font>，有些应用程序（在</font></font><span class="Vocabulary_Word "><font><font>对等体</font></font></span><font><font>）作为在同一时间的客户端和服务器。</font></font></p>

   <a name="limit"></a>
	<h3><font><font>插槽的限制</font></font></h3>
	<p><font><font>在某些方面，一个插座就像一个文件。</font><font>两者都包含有开始和结束的数据。</font><font>既可以写入或读出。</font><font>但在其他方面，他们不同，这些差异驱动协议的设计。</font></font></p>
	<p><font><font>首先，虽然一个文件是通常用于读出或写入，一个插座是交互式的。</font><font>应用程序必须能够打断，并提醒对方，改变对方的行为。</font><font>因为这个原因，数据被分成数据包，和这种划分留下一个开口，用于中断。</font></font></p>
	<p><font><font>其次，虽然一个文件具有已知大小，插座不具有大小。</font><font>一个应用程序不能知道多少数据留在当前包中，除非协议本身指定此。</font><font>因此，所有的数据包包括隐式或显式的大小的信息或标记，以指示当数据包结束。</font></font></p>
	<p><font><font>第三，虽然一个文件是可靠的，一个插座是不可靠的。</font><font>当从插座读取，数据到达块中，每个块之间可能的大的延迟，并且没有办法知道一个特定的延迟是否是因为由于意外断开高流量或。</font><font>因此，应用程序被迫把长的延迟，如果它是一个断线，并且协议规定超时和重试的消息来规范这一点。</font></font></p>
	<p><font><font>该AsyncSocket库的目的​​是使这些协议的考虑容易对付。</font></font></p>

   <a name="struct"></a>
	<h3><font><font>数据包结构</font></font></h3>
	<p><font><font>网络通信协议采用某些共同所有的协议的基本要素。</font><font>这些都是：</font></font></p>
	<ul>
		<li>
		<p><font><font>一个</font></font><span class="Vocabulary_Word "><font><font>领域</font></font></span><font><font>。</font><font>这是一个数据包的基本组成部分。</font><font>字段是字节，通常较短，这被解释为一个单元的序列。</font><font class="">字段可以是表示一个号码，一个或多个字符，二进制数据枚举的序列，或一系列位标志。</font></font></p>
		<p><font><font>如果字段是一个数字，超过一个字节长，该协议必须指定数量的字节是否应该被安排在“小尾数”，“大端”，或“网络”字节顺序。</font><font>Carbon和Cocoa都提供了字节顺序的功能，可以处理不同的字节顺序。</font></font></p>
		<p><font><font>一个字段可以是固定长度或可变长度。</font><font>一个的长度</font></font><span class="Vocabulary_Word "><font><font>固定长度字段</font></font></span><font><font>由协议指定。</font><font>一个长度</font></font><span class="Vocabulary_Word "><font><font>可变长度字段</font></font></span><font><font>指定或隐或显。</font><font>在前者的情况下，可变长度字段（</font></font><span class="Vocabulary_Word "><font><font>数据字段</font></font></span><font><font>）之前，将一个固定长度的数字字段（该</font></font><span class="Vocabulary_Word "><font><font>长度字段</font></font></span><font><font>），该指定数据字段的长度。</font><font>在后一种情况下，一个字节序列（</font></font><span class="Vocabulary_Word "><font><font>定界符</font></font></span><font><font>）将标记字段结束。</font></font></p>
		</li>
		<li>
		<p><font><font>一个</font></font><span class="Vocabulary_Word "><font><font>文本行</font></font></span><font><font>。</font><font>这是字符数据，通常编码为ASCII。</font><font>一个</font></font><span class="Vocabulary_Word "><font><font>行结束</font></font></span><font><font>，标志着该行的末尾。</font><font>有三种常用的行尾：CR，LF和CRLF。</font><font>该协议必须指定将被使用。</font><font>许多基于文本的协议，分一分文本行成用空格等字符分隔变长字段。</font></font></p>
		</li>
		<li>
		<p><font><font>甲</font></font><span class="Vocabulary_Word "><font><font>分组</font></font></span><font><font>，由一个的</font></font><span class="Vocabulary_Word "><font><font>分组报头</font></font></span><font><font>和一</font></font><span class="Vocabulary_Word "><font><font>有效载荷</font></font></span><font><font>。</font><font>分组报头包含描述有效负载的类型（以及可能的长度）固定长度的字段。</font><font>有效载荷包含一系列可变长度和固定长度的字段，它根据有效载荷类型而变化的。</font></font></p>
		</li>
		<li>
		<p><font><font>甲</font></font><span class="Vocabulary_Word "><font><font>数据流</font></font></span><font><font>，连续的字节序列。</font><font>在数据流的末尾标记由连接的关闭。</font><font>一个数据流可以被视为一个巨大的非结构化数据包。</font><font>当一个应用程序正在发送一个数据流，协议通常不允许接收应用程序中断的发送应用程序。</font></font></p>
		<p><font><font>的数据流之前可以由一个</font></font><span class="Vocabulary_Word "><font><font>数据流头标</font></font></span><font><font>，一系列描述的数据流的可变长度和固定长度的字段。</font></font></p>
		</li>
	</ul>
	<p><font><font>“ </font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#parse"><font><font>解析包</font></font></a><font><font> “介绍如何使用</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>方法来读取这些不同的元素。</font></font></p>

   <a name="using"></a>
	<h2><font><font>使用AsyncSocket</font></font></h2>
	<p><font><font>该AsyncSocket库由一个类，也称为</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>。</font><font>的一个实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>表示一个插座，它可以是一个侦听套接字或一个连接插座。</font><font>一个实例，也可以断开，在这种情况下，它并不代表一个有效的插座。</font><font>在本文档中，术语“插座”和“实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font> “用于几乎互换。</font></font></p>
	<p><font><font>要使用</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>类项目，新增</font></font><span class="Filename "><font><font>AsyncSocket.m</font></font></span><font><font>和</font></font><span class="Filename "><font><font>/System/Library/Frameworks/CoreServices.framework</font></font></span><font><font>到项目，并导入</font></font><span class="Filename "><font><font>AsyncSocket.h</font></font></span><font><font>到每个需要它的文件。</font></font></p>
	<p><font><font>此版本AsyncSocket的需要Mac OS X 10.4或更高版本。</font><font>如果你必须支持Mac OS X 10.3，您可以使用AsyncSocket版本3.13。</font></font></p>

   <a name="owner"></a>
	<h3><font><font>插座所有权</font></font></h3>
	<p><font><font>在客户端 - 服务器体系结构中，应用程序充当客户端通常采用一个连接插座与服务器进行通信，和一个应用程序充当服务器通常采用一个侦听套接字接受来自客户端和几个连接插座连接与连接到通信客户端。</font><font>在一个对等架构，应用程序通常采用一个监听套接字和若干连接插座，就好像它是一台服务器。</font></font></p>
	<p><font><font>每个插座应该由管理</font></font><span class="Vocabulary_Word "><font><font>连接控制器</font></font></span><font><font>类。</font><font>此类应负责：</font></font></p>
	<ul>
		<li><font><font>拥有网络连接的本地套接字。</font></font></li>
		<li><font><font>构建和写作传出的数据包。</font></font></li>
		<li><font><font>读和解析进入的数据包。</font></font></li>
		<li><font><font>检测和处理错误情况。</font></font></li>
	</ul>
	<p><font><font>连接插座的集合应该由管理</font></font><span class="Vocabulary_Word "><font><font>连接阵列控制器</font></font></span><font><font>。</font><font>这个类应该负责创建，并根据需要摧毁单个连接控制器。</font><font>每个管理连接控制器应该保持通报其状态的连接阵列控制器。</font></font></p>
	<p><font><font>如果应用程序有一个侦听套接字，应该拥有和连接阵列控制器进行管理。</font><font>当监听套接字接受连接，连接阵列控制器应建立负责管理新连接的新连接器。</font></font></p>

   <a name="deleg"></a>
	<h3><font><font>委托方法</font></font></h3>
	<p><font><font>的一个实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>在完成某些操作或遇到某些错误将消息发送到它的委托对象。</font><font>的所有实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>应该有一个代表响应这些消息正确。</font><font>的委托对象应该是插座的连接器或连接阵列控制器。</font></font></p>
	<p><font><font>的委托对象应按照插座的目的实现以下委托方法（见“ </font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#ref"><font><font>参考AsyncSocket</font></font></a><font><font> “下面的具体描述）：</font></font></p>
	<ul>
		<li>
		<p><font><font>所有代表应该实现</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdiddisconnect"><font><font>-onSocketDidDisconnect：</font></font></a><font><font>用于清理。</font></font></p>
		</li>
		<li>
		<p><font><font>所有代表应该实现</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>错误恢复和日志记录。</font></font></p>
		</li>
		<li>
		<p><font><font>代表们听取控制插座应实施</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidacceptnewsock"><font><font>-onSocket：didAcceptNewSocket： </font></font></a><font><font>。</font><font>代表们还应该实现</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwantsrunloopnewsock"><font><font>-onSocket：wantsRunLoopForNewSocket：</font></font></a><font><font>如果连接应该被引导到各个线程。</font></font></p>
		</li>
		<li>
		<p><font><font>代表们控制连接套接字或接受的连接应实现</font></font><a class="Function " href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidconnecthostport"><font><font>-onSocket：didConnectToHost：端口：</font></font></a><font><font>，</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>和</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidwritedatatag"><font><font>-onSocket：didWriteDataWithTag： </font></font></a><font><font>。</font><font>代表们还应该实现</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwillconnect"><font><font>-onSocketWillConnect：</font></font></a><font><font>如果套接字的底层可可对象需要进行定制。</font></font></p>
		</li>
	</ul>
	<p><font><font>你很少会需要改变一个插座的委托，但在需要时，要小心。</font><font>如果一个套接字完成任何读或写在旧的委托发起的行动，新的代表将被通知，不老的委托。</font><font>您可以检查待处理的读取或发送写操作</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_cansafelysetdelegate"><font><font>-canSafelySetDelegate：</font></font></a><font><font>套接字。</font><font>请参阅“ </font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#rw"><font><font>阅读与写作</font></font></a><font><font> “下面的未决读或写操作的讨论。</font></font></p>
	<p><font><font>的几个实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>可以安全地共享一个委托对象。</font><font>每个实例传递本身，因为它发出的任何委托消息的第一个参数。</font><font class="">这样区分的委托对象</font></font><span class="Class"><font><font class="">AsyncSocket</font></font></span><font><font class="">实例。</font></font></p>

   <a name="conn"></a>
	<h3><font><font>接受，连接和断开</font></font></h3>
	<p><font><font>要启动到远程套接字在给定的套接字地址的连接，发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>-connectToHost：onPort：错误：</font></font></a><font><font>到插座，传递主机地址和端口作为参数。</font><font>主机地址可以是IP地址或DNS名称，包括“本地主机”。DNS名称不包含端口号。</font></font></p>
	<p><font><font>要建立一个监听套接字给定端口，发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>-acceptOnPort：错误：</font></font></a><font><font>套接字。</font><font>套接字将侦听所有可用的主机地址。</font><font>要建立一个套接字侦听只有一个地址，发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptaddressporterror"><font><font>-acceptOnAddress：端口：错误：</font></font></a><font><font>。</font><font>有选择地向特定线程直接传入的连接，实现</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwantsrunloopnewsock"><font><font>-onSocket：wantsRunLoopForNewSocket：</font></font></a><font><font>在插座的委托。</font></font></p>
	<p><font><font>要改变套接字的底层的性能</font></font><a class="Class"><font><font>CFReadStream</font></font></a><font><font>或</font></font><a class="Class"><font><font>CFWriteStream</font></font></a><font><font>对象（例如，为了支持SSL连接）实施</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwillconnect"><font><font>-onSocketWillConnect：</font></font></a><font><font>在插座的委托。</font></font></p>
	<p><font><font>干净断开插座，送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_disconnectafterwriting"><font><font>-disconnectAfterWriting</font></font></a><font><font>套接字。</font><font>此方法将断开连接之前完成所有写操作。</font><font>要立即断开，送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_disconnect"><font><font>-disconnect</font></font></a><font><font>。</font><font>在两种情况下，插座将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdiddisconnect"><font><font>-onSocketDidDisconnect：</font></font></a><font><font>给委托后它完成断开。</font></font></p>
	<p><font><font>如果远程干净插座从本地插座断开，本地套接字将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>到委托。</font><font>该消息的</font></font><span class="Argument"><font><font>错误</font></font></span><font><font>论点将是</font></font><span class="Constant"><font><font>零</font></font></span><font><font>（请参阅“ </font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#err"><font><font>错误处理</font></font></a><font><font> “下）。</font><font>本地套接字将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdiddisconnect"><font><font>-onSocketDidDisconnect：</font></font></a><font><font>到委托。</font></font></p>

   <a name="rw"></a>
	<h3><font><font>阅读和写作</font></font></h3>
	<p><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>处理读取和写入操作本身。</font><font>您可以指定你想要的操作，并</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>拿它出来尽快并发送消息给委托时，操作完成。</font></font></p>
	<p><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>支持三个读出操作（“读与长度”，“读至数据”，和“读任意”）和一个写操作（“写数据”）。</font></font></p>
	<ul>
		<li>
		<p><font><font>在“读-长度”操作读取一定数量从远程套接字的字节。</font><font>要执行此操作，发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatalengthtimeouttag"><font><font>-readDataToLength：withTimeout：标签：</font></font></a><font><font>套接字。</font></font></p>
		</li>
		<li>
		<p><font><font>在“读-数据”操作读取所有字节高达（包括）分隔符序列。</font><font>要执行此操作，发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatadatatimeouttag"><font><font>-readDataToData：withTimeout：标签：</font></font></a><font><font>套接字。</font></font></p>
		</li>
		<li>
		<p><font><font>在“读什么”的操作读取第一个可用的字节。</font><font>要执行此操作，发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatatimeouttag"><font><font>-readDataWithTimeout：标签：</font></font></a><font><font>套接字。</font></font></p>
		</li>
		<li>
		<p><font><font>“写数据”操作将一个数据对象到远程插座。</font><font>要执行此操作，发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_writedatatimeouttag"><font><font>-writeData：withTimeout：标签：</font></font></a><font><font>套接字。</font></font></p>
		</li>
	</ul>
	<p><font><font>调用读取或写入方法如果可能的话会立即执行请求的操作。</font><font class="">但是，如果该操作不能立即完成，它将被放置在一个读或写队列。</font></font><span class="Class"><font><font class="">AsyncSocket</font></font></span><font><font class="">将继续在后台顺序执行排队的操作。</font></font></p>
	<p><font><font>要检查当前执行的“读来长”或“写数据”操作的进度，您可以发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_progressreadtagbytesdonetotal"><font><font>-progressOfReadReturningTag：bytesDone：总：</font></font></a><font><font>或</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_progresswritetagbytesdonetotal"><font><font>-progressOfWriteReturningTag：bytesDone：总：</font></font></a><font><font>套接字。</font><font>这些方法返回0.0和1.0之间的十进制数，而你也可以得到读取或写入的总字节数。
	</font></font></p><p><font><font>该读写操作支持可选的超时。</font><font>超时值是几秒钟的十进制数，例如1.5。</font><font>超时值指定的操作可以采取一次开始多久。</font><font>排队的操作不会开始运行的时间，直到它开始执行。</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>如果你发送一个负的超时参数将使用系统定义的超时值。</font></font></p>
	<p><font><font>如果一个操作耗尽的时间完成之前，插座将断开。</font><font>如果你的协议支持，从拖延已久的传输恢复机制，可以通过提供自己的“软”超时</font></font><span class="Class"><font><font>NSTimer的</font></font></span><font><font>对象，而不是或除了AsyncSocket自己的超时系统。</font></font></p>
	<p><font><font>当一个操作已在规定时间内完成，套接字将消息发送到其委托（无论是</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>或</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidwritedatatag"><font><font>-onSocket：didWriteDataWithTag： </font></font></a><font><font>）。</font><font>的委托对象应作出适当反应，发出另一次读或写邮件到插座是必要的。</font></font></p>
	<p><font><font>为了帮助恰当的委托对象响应，您可以提供一个标签值作为读取参数或写入消息。</font><font>标记值可以是整数，指针或对象ID。</font><font>标签值不被发送到远程套接字，和远程套接字不发送标记值到本地套接字。</font><font>但是在完成该操作由本地套接字发送到其代表该消息包括最初提供的标记值。</font><font>标记值可以用于“记住”其下操作开始的情况。</font><font>标记值可以标记类型的操作，或指定的多操作处理的步骤。</font></font></p>

   <a name="parse"></a>
	<h3><font><font>解析包</font></font></h3>
	<p><font><font>解析一个数据包，或阅读数据流，一行文字或数据流头，考虑如何把它分解成一系列简单的读取操作。</font></font></p>
	<p><font><font>这里有一些技巧，你可以用它来读取和解析协议的内容：</font></font></p>
	<ul>
		<li>
		<p><font><font>任何个别固定长度字段可以由一个“读与长度”的操作被读出。</font><font>但你也可以阅读一系列固定长度字段的一次。</font><font>字段将被收集在一个单一的数据对象。</font><font>您可以通过使用一个C结构，如在此示例代码很容易恢复各个领域：</font></font></p>
		<div class="Sample_Code "><font><font>
UInt32的FIELD1，FIELD2; </font><font>结构域{field1的UInt32的; </font><font>UInt32的FIELD2; </font><font>}; </font><font>结构字段* fieldSeries =（结构字段*）[receivedData字节]; </font><font>字段1 = fieldSeries-&gt;字段1; </font><font>FIELD2 = fieldSeries-&gt; FIELD2;</font></font></div>
		<p><font><font>如果只有固定长度字段包括一个数据包，您可以使用此技术来读取整个包一次。</font></font></p>
		</li>
		<li>
		<p><font><font>任何分隔的可变长度字段可以由一个单一的“读至数据”操作中读取的全部内容。</font></font></p>
		</li>
		<li>
		<p><font><font>之前有一个固定长度的长度字段的可变长度的数据字段可被读取两部分。</font><font>使用一个“读与长度”操作来读取长度字段。</font><font>这会告诉你的数据字段有多长。</font><font>使用另一种“读来长”操作来读取数据字段。</font></font></p>
		</li>
		<li>
		<p><font><font>一个包也可以读取在两个（或更多个）部分。</font><font>使用一个“读 - 长”操作来读取整个固定长度的数据包报头。</font><font>提取从报头的有效载荷的长度，并使用上述技术读取有效负载的领域。</font></font></p>
		</li>
		<li>
		<p><font><font>一行文本可以被视为一个可变长度字段被结束的行分隔。</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>提供了返回CR，LF和CRLF行结束符的消息。</font><font>您的客户端应用程序将收到的文本行作为一个数据对象。</font><font>然后，可以将数据对象转换为字符串对象，并使用</font></font><span class="Class"><font><font>的NSString</font></font></span><font><font>和</font></font><span class="Class"><font><font>NSScanner</font></font></span><font><font>类打破行成单个字段。</font></font></p>
		</li>
		<li>
		<p><font><font>数据的流头部而变化的格式，但可被视为固定或可变长度的字段，并使用上述技术进行解析。</font></font></p>
		</li>
		<li>
		<p><font><font>一个数据流可以读取与两个技术之一。</font><font>第一种技术是在适当的时候流中的数据，因为它到达必须进行处理，或者如果不知道数据的大小：</font></font></p>
		<ol>
			 <li>
			<p><font><font>发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatatimeouttag"><font><font>-readDataWithTimeout：标签：</font></font></a><font><font>套接字。</font></font></p>
			 </li>
			 <li>
			<p><font><font>当数据到达时，插座就会发送发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>到委托。</font><font>处理或存储数据。</font></font></p>
			 </li>
			 <li>
			<p><font><font>发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatatimeouttag"><font><font>-readDataWithTimeout：标签：</font></font></a><font><font>插座上的委托方法返回之前。</font></font></p>
			 </li>
			 <li>
			<p><font><font>重复，直到连接关闭。</font><font>在委托对象的</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>方法，发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatatimeouttag"><font><font>-readDataWithTimeout：标签：</font></font></a><font><font>插座上的最后一次。</font></font></p>
			 </li>
		</ol>
		<p><font><font>当你知道数据流的大小，并希望在一个单一的数据对象的整个流返回的第二种技术只能用于：</font></font></p>
        <ol>
            <li><p><font><font>发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatalengthtimeouttag"><font><font>-readDataToLength：withTimeout：标签：</font></font></a><font><font>套接字。</font></font></p></li>
            <li><p><font><font>等待委托对象的</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag</font></font></a><font><font>要调用的方法。</font></font></p></li>
        </ol>
		</li>
	</ul>

   <a name="err"></a>
	<h3><font><font>错误处理</font></font></h3>
	<p><font><font>
		如果一个插座遇到输入/输出错误，或如果一个读或写操作超时，AsyncSocket假定连接已被中断，必须要重新建立。</font><font>套接字将继续断开本身。</font><font>远程套接字将通常由它自己的客户端应用程序被断开。
	</font></font></p>
	<p><font><font>
		在断开本地套接字，一个</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>实例将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>它的委托对象。</font><font>此消息的第二个参数是一个</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>对象。</font><font>该目的可以含有POSIX，Mac OS或者</font></font><span class="Class"><font><font>CFStream</font></font></span><font><font>错误代码，由对象的指示</font></font><span class="Function "><font><font>-domain</font></font></span><font><font>方法。</font><font>它也可以含有</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>特异性错误代码。</font><font>请参阅“ </font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdomain"><font><font>错误</font></font></a><font><font> “的详细信息。
	</font></font></p>
	<p><font><font>
		在其执行</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>的方法，该委托对象可以通过发送检索所有未接收的数据（包括来自任何部分完成的读取操作的数据）</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_unreaddatatag"><font><font>-unreadData</font></font></a><font><font>套接字。
	</font></font></p>
	<p><font><font>
		委托对象后</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>willDisconnectWithError：-onSocket</font></font></a><font><font>方法返回时，套接字将被断开。</font><font>然后，它将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdiddisconnect"><font><font>-onSocketDidDisconnect：</font></font></a><font><font>到委托。
	</font></font></p>

   <a name="thread"></a>
	<h3><font><font>线程和运行循环</font></font></h3>
	<p><font><font>一个</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>实例必须在同一个运行循环一起使用。</font><font>其运行循环活动发生在</font></font><span class="Constant"><font><font>NSDefaultRunLoopMode</font></font></span><font><font>模式。</font></font></p>
	<p><font><font>一个</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>实例可以使用来自一个工作线程或主线程。</font><font>然而，每个实例应仅由一个线程使用，因此，该实例不从错误的线程上下文中调用委托方法。</font></font></p>
	<p><font><font>要创建一个连接或在特定线程监听套接字，只需创建套接字在该线程的上下文中。</font></font></p>
	<p><font><font>监听套接字创建一个新的socket时，接受连接。</font><font>为了确保这一新的插座在特定线程创建的，从监听套接字的返回线程的运行循环</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwantsrunloopnewsock"><font><font>-onSocket：wantsRunLoopForNewSocket：</font></font></a><font><font>委托方法。</font></font></p>

   <a name="sub"></a>
	<h3><font><font>定制AsyncSocket</font></font></h3>
	<p><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>并不旨在是子类。</font><font>然而，由于</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>是在公共领域，你可以改变它，就像你喜欢你自己的项目。</font><font>源代码的编写是可以理解的。</font></font></p>
	<p><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>使用</font></font><span class="Class"><font><font>CFSocket</font></font></span><font><font>，</font></font><span class="Class"><font><font>CFReadStream</font></font></span><font><font>和</font></font><span class="Class"><font><font>CFWriteStream</font></font></span><font><font>内部。</font><font>您可以直接访问这些并设置任何属性或行为，您可能需要。</font><font>该</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwillconnect"><font><font>-onSocketWillConnect：</font></font></a><font><font>委托方法旨在促进这一点。</font></font></p>

   <a name="ref"></a>
	<h2><font><font>AsyncSocket参考</font></font></h2>
	<p><font><font>请参阅“ </font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#idx"><font><font>API指数</font></font></a><font><font> “的消息，方法，类型和常量的字母顺序列表。</font></font></p>

   <a name="api_alloc"></a>
	<h3><font><font>初始化和取消分配消息</font></font></h3>
	<p><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>不提供自动释放方便初始化。</font></font></p>
   <p><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_init"><font><font>-init </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_initdelegate"><font><font>-initWithDelegate：</font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_initdelegateuserdata"><font><font>-initWithDelegate：USERDATA：</font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_dealloc"><font><font>-dealloc</font></font></a></p>

   <a name="api_init"></a>
	<p class="Method_Heading"><font><font>-init</font></font></p>
	<p><font><font>此消息初始化接收器，无需设置委托。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （ID）的init</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td><p><font><font>的一个实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_initdelegate"></a>
	<p class="Method_Heading"><font><font>-initWithDelegate：</font></font></p>
	<p><font><font>此消息初始化接收机，设置代表在同一​​时间。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （ID）initWithDelegate：（ID）代表</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p><p></p></th>
		<td class="Argument"><p><font><font>代表</font></font></p></td>
		<td>
			<p><font><font>一个对象，将作为委托接收器。</font><font>该代表应实施必要的</font></font><span class="Class"><font><font>AsyncSocketDelegate</font></font></span><font><font>方法。</font></font></p>
			<p><font><font>可能是</font></font><span class="Constant"><font><font>零</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p>
		</th><td colspan="2">
			 <p><font><font>的一个实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2"><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_initdelegateuserdata"></a>
	<p class="Method_Heading"><font><font>-initWithDelegate：USERDATA：</font></font></p>
	<p><font><font>此消息初始化接收机，同时设定该委托和用户数据。</font><font>此方法是AsyncSocket实例的指定初始化。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （ID）initWithDelegate：（ID）代表用户数据：（长）USERDATA</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="2"><p><font><font>参数</font></font></p><p></p></th>
		<td class="Argument"><p><font><font>代表</font></font></p></td>
		<td>
			<p><font><font>一个对象，将作为委托接收器。</font><font>该代表应实施必要的</font></font><span class="Class"><font><font>AsyncSocketDelegate</font></font></span><font><font>方法。</font></font></p>
			<p><font><font>可能是</font></font><span class="Constant"><font><font>零</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>USERDATA</font></font></p></td>
		<td>
			<p><font><font>将与接收器相关联的值。</font><font>它可以在以后通过检索一个</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_userdata"><font><font>-userData：</font></font></a><font><font>消息。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p>
		</th><td colspan="2">
			 <p><font><font>的一个实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2"><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_dealloc"></a>
	<p class="Method_Heading"><font><font>-dealloc</font></font></p>
	<p><font><font>此消息将释放接收器，如果需要的话断开。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td><span class="Body Code "><font><font> - （无效）的dealloc</font></font><p></p></span></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

	<a name="api_ud"></a>
	<h3><font><font>用户数据信息</font></font></h3>
	<p><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_userdata"><font><font>-userData </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_setuserdata"><font><font>-setUserData：</font></font></a></p>

	<a name="api_userdata"></a>
	<p class="Method_Heading"><font><font>-userData</font></font></p>
	<p><font><font>该消息返回接收器的当前用户数据，与接收器相关联的arbitary值。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （长）USERDATA</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td><p><font><font>当前用户数据。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

	<a name="api_setuserdata"></a>
	<p class="Method_Heading"><font><font>-setUserData：</font></font></p>
	<p><font><font>此消息设置接收者的用户数据，与接收器相关联的arbitary值。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）setUserData：（长）USERDATA</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>USERDATA</font></font></p></td>
		<td>
			 <p><font><font>将与接收器相关联的值。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2"><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2"><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_deleg"></a>
	<h3><font><font>代表团消息</font></font></h3>
   <p><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_delegate"><font><font>-delegate </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_setdelegate"><font><font>-setDelegate：</font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_cansafelysetdelegate"><font><font>-canSafelySetDelegate</font></font></a></p>
   
   <a name="api_delegate"></a>
	<p class="Method_Heading"><font><font>-delegate</font></font></p>
	<p><font><font>该消息返回接收当前的委托对象。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （ID）代表</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td><p><font><font>目前委托对象，或</font></font><span class="Constant"><font><font>零</font></font></span><font><font>。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_setdelegate"></a>
	<p class="Method_Heading"><font><font>-setDelegate：</font></font></p>
	<p><font><font>此消息集接收机的委托对象。</font><font>该委托对象不保留。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）setDelegate：（ID）代表</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>代表</font></font></p></td>
		<td>
			 <p><font><font>一类是将充当委托接收机的一个实例。</font><font>要实施必要的</font></font><span class="Class"><font><font>AsyncSocketDelegate</font></font></span><font><font>方法。</font></font></p>
			 <p><font><font>可能是</font></font><span class="Constant"><font><font>零</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2"><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2"><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>如果委托对象发生变化，旧的委托对象将不再接收，这可能期望为未决读或写操作，它开始产生的任何消息。</font><font>为了确保没有挂起读或写操作，委托对象可以调用</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_cansafelysetdelegate"><font><font>-canSafelySetDelegate： </font></font></a><font><font>。</font></font></p>
	
   <a name="api_cansafelysetdelegate"></a>
	<p class="Method_Heading"><font><font>-canSafelySetDelegate</font></font></p>
	<p><font><font>该消息可以被发送到确定一个新的委托对象是否需要被意识到挂起的读或写操作。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （BOOL）canSafelySetDelegate</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><span class="Constant"><font><font>YES</font></font></span><font><font>，如果接收器有任何未决的读或写操作。</font></font></p>
			 <p><span class="Constant"><font><font>否</font></font></span><font><font>，如果接收机没有挂起的读或写操作。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_conn"></a>
	<h3><font><font>连接消息</font></font></h3>
   <p><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>-connectToHost:onPort:error: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>-acceptOnPort:error: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptaddressporterror"><font><font>-acceptOnAddress:port:error: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_isconnected"><font><font>-isConnected </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_disconnect"><font><font>-disconnect </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_disconnectafterwriting"><font><font>-disconnectAfterWriting </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connectedhost"><font><font>-connectedHost </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connectedport"><font><font>-connectedPort </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_localhost"><font><font>-localHost </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_localport"><font><font>-localPort</font></font></a></p>
   <a name="api_connecthostporterror"></a>
	<p class="Method_Heading"><font><font>-connectToHost：onPort：错误：</font></font></p>
	<p><font><font>这个消息建立从接收呼出连接。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （BOOL）在connectToHost：（*的NSString）主机名onPort：（UINT16）端口错​​误：（NSError **）ERR</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="3"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>主机名</font></font></p></td>
		<td>
			 <p><font><font>DNS名称或IP地址与接收应该连接。</font><font>IPv4和IPv6地址的支持。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>港</font></font></p>
		</td><td>
			 <p><font><font>到接收器应连接的端口号。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>犯错</font></font></p></td>
		<td>
			 <p><font><font>一个地址</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>对象的指针。</font><font>在一个错误的情况下，指针将被设置为</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>描述错误的对象。</font></font></p>
			 <p><font><font>发送方可以通过</font></font><span class="Constant"><font><font>零</font></font></span><font><font>，如果它不希望检索任何</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>对象。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
			 <p><font><font>返回</font></font><span class="Constant"><font><font>YES</font></font></span><font><font>，如果连接成功。</font></font></p>
			 <p><font><font>这并不表示套接字准备好使用。</font><font>该插座仅准备当</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidconnecthostport"><font><font>-onSocket：didConnectToHost：端口：</font></font></a><font><font>委托方法被调用。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2">
			 <p><font><font>返回</font></font><span class="Constant"><font><font>否</font></font></span><font><font>和一个</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>在下列条件下对象：</font></font></p>
			 <ul>
			<li><span class="Argument"><font><font>主机</font></font></span><font><font>是不是一个有效的地址，或者没有这样的地址。</font></font></li>
			<li><font><font>插座无法创建，或者不能连接到该地址。</font></font></li>
			 </ul>
			 <p><font><font>返回</font></font><span class="Constant"><font><font>YES</font></font></span><font><font>并调用</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>在下列条件下：</font></font></p>
			 <ul>
			<li><font><font>在读取和写入数据流无法连接或打开。</font></font></li>
			 </ul>
            <p><font><font>引发</font></font><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockexception"><font><font>AsyncSocketException</font></font></a><font><font>如果已经连接套接字或接受连接，如果没有委托已设置。</font></font></p>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>如果接收机返回</font></font><span class="Constant"><font><font>是</font></font></span><font><font>，它会继续建立连接。</font><font>当成功建立连接，或者无法建立，接收机将发送一个适当的消息给它的委托对象。</font></font></p>
	<p><font><font>读和写操作可以被排队之前的成功建立连接。</font><font>他们将被执行后，连接完成。</font></font></p>

   <a name="api_acceptporterror"></a>
	<p class="Method_Heading"><font><font>-acceptOnPort：错误：</font></font></p>
	<p><font><font>此消息确立了接收器监听套接字将接受传入的连接。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （BOOL）acceptOnPort：（UINT16）端口错​​误：（NSError **）ERR</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="2"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>港</font></font></p></td>
		<td>
			 <p><font><font>在该接收器应该接受连接的端口号。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>犯错</font></font></p></td>
		<td>
			 <p><font><font>一个地址</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>对象的指针。</font><font>在一个错误的情况下，指针将被设置为</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>描述错误的对象。</font></font></p>
			 <p><font><font>发送方可以通过</font></font><span class="Constant"><font><font>零</font></font></span><font><font>，如果它不希望检索任何</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>对象。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
			 <p><font><font>返回</font></font><span class="Constant"><font><font>YES</font></font></span><font><font>如果接收机被成功接受在指定的端口连接。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2">
			 <p><font><font>返回</font></font><span class="Constant"><font><font>NO</font></font></span><font><font>和</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>如果套接字不能被创建，或不能接受指定的端口上的连接对象。</font></font></p>
            <p><font><font>引发</font></font><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockexception"><font><font>AsyncSocketException</font></font></a><font><font>如果已经连接套接字或接受连接，如果没有委托已设置。</font></font></p>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>该接收器建立与监听套接字</font></font><span class="Constant"><font><font>SO_REUSEADDR</font></font></span><font><font>选项集。</font></font></p>
	<p><font><font>在从远程套接字的连接的情况下，接收器将创建一个新的</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>实例。</font><font>新的实例将具有相同的委托对象的接收器，以及将尝试完成连接到远程套接字。</font></font></p>
	<p><font><font>有新的实例的尝试的三种可能的结果。</font><font>首先，尝试能成功。</font><font>其次，尝试可能会失败，因为本地套接字无法创建。</font><font>第三，尝试可能因为另一个问题失败。</font></font></p>
	<p><font><font>如果成功的话，接收器会发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidacceptnewsock"><font><font>-onSocket：didAcceptNewSocket：</font></font></a><font><font>和</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwantsrunloopnewsock"><font><font>-onSocket：wantsRunLoopForNewSocket：</font></font></a><font><font>它的委托对象。</font><font>在这一点上的委托对象可以改变新实例的委托对象或分配一个运行循环。</font><font>后委托方法返回，新的实例将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidconnecthostport"><font><font>-onSocket：didConnectToHost：端口：</font></font></a><font><font>它的委托对象。</font></font></p>
	<p><font><font>如果不成功，因为本地套接字无法创建，新的实例将被销毁默默地，并且接收器将继续接受连接。</font></font></p>
	<p><font><font>如果不成功某些其他原因，接收器就会发出</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidacceptnewsock"><font><font>-onSocket：didAcceptNewSocket：</font></font></a><font><font>和</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwantsrunloopnewsock"><font><font>-onSocket：wantsRunLoopForNewSocket：</font></font></a><font><font>它的委托对象。</font><font>委托方法返回后，新的实例将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>其委托有关故障状况的详情。</font></font></p>

   <a name="api_acceptaddressporterror"></a>
	<p class="Method_Heading"><font><font>-acceptOnAddress：端口：错误：</font></font></p>
	<p><font><font>此消息确立了接收器监听套接字，将接受一个特定的主机地址和端口传入的连接。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （BOOL）acceptOnAddress：（*的NSString）端口地址hostaddr：（UINT16）端口错​​误：（NSError **）ERR</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="3"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>正确提供hostaddr</font></font></p></td>
		<td>
			<p><font><font>主机地址在哪方应当接受连接。</font><font>地址应该是IPv4或IPv6地址，如“192.168.3.1”或“为fe80 :: 230：65ff：FE29：aa9d”</font></font></p>
			<p><font><font>如果</font></font><span class="Constant"><font><font>为零</font></font></span><font><font>或空字符串，效果是一样的</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>-acceptOnPort：错误：</font></font></a><font><font>消息。 
		</font></font></p></td></tr><tr>
		<td class="Argument"><p><font><font>港</font></font></p></td>
		<td>
			 <p><font><font>在该接收器应该接受连接的端口号。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>犯错</font></font></p></td>
		<td>
			 <p><font><font>一个地址</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>对象的指针。</font><font>在一个错误的情况下，指针将被设置为</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>描述错误的对象。</font></font></p>
			 <p><font><font>发送方可以通过</font></font><span class="Constant"><font><font>零</font></font></span><font><font>，如果它不希望检索任何</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>对象。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
			 <p><font><font>返回</font></font><span class="Constant"><font><font>YES</font></font></span><font><font>如果接收机被成功接受在指定的端口连接。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2">
			 <p><font><font>返回</font></font><span class="Constant"><font><font>NO</font></font></span><font><font>和</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>如果套接字不能被创建，或不能接受指定的地址或端口的连接对象。</font></font></p>
            <p><font><font>引发</font></font><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockexception"><font><font>AsyncSocketException</font></font></a><font><font>如果已经连接套接字或接受连接，如果没有委托已设置。</font></font></p>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>见</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>-acceptOnPort：错误：</font></font></a><font><font>了解更多信息。</font></font></p>

   <a name="api_isconnected"></a>
	<p class="Method_Heading"><font><font>-isConnected</font></font></p>
	<p><font><font>该消息可被发送，以确定接收机是否被连接以及能够读取和写入。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font> - （BOOL）isConnected</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><span class="Constant"><font><font>是</font></font></span><font><font>，如果该接收器连接，并能够发送和接收数据。</font></font></p>
			 <p><span class="Constant"><font><font>否</font></font></span><font><font>，如果接收机没有连接，接受连接，或不能够发送和接收数据。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>如果输入或输出流都达到</font></font><span class="Constant"><font><font>EOF</font></font></span><font><font>时，接收器返回</font></font><span class="Constant"><font><font>否</font></font></span><font><font>。</font><font>如果输入或输出流是开放的，但在其他一些错误状态时，接收器返回</font></font><span class="Constant"><font><font>YES</font></font></span><font><font>。</font></font></p>
	<p><font><font>如果接收器接收传入的连接，它总是返回</font></font><span class="Constant"><font><font>NO</font></font></span><font><font>。</font></font></p>

   <a name="api_disconnect"></a>
	<p class="Method_Heading"><font><font>-disconnect</font></font></p>
	<p><font><font>此消息立即断开连接接收器。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font> - （无效）断开</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>如果接收器被接受传入的连接，它不会停止这样做。</font><font>任何待读或写操作都将被丢弃。</font></font></p>
	<p><font><font>此方法返回后，客户端应用程序可以发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>-connectToHost：onPort：错误：</font></font></a><font><font>，</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>-acceptOnPort：错误：</font></font></a><font><font>，或</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptaddressporterror"><font><font>：-acceptOnAddress：端口：错误</font></font></a><font><font>再次消息。</font></font></p>
	
   <a name="api_disconnectafterwriting"></a>
	<p class="Method_Heading"><font><font>-disconnectAfterWriting</font></font></p>
	<p><font><font>完成所有待定写操作之后，此消息将断开接收器。</font><font>待处理读操作不会阻止接收机断开。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font> - （无效）disconnectAfterWriting</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>而挂起写操作完成，接收器会忽略任何进一步的读或写邮件。</font><font>其他消息可以发送如常。</font></font></p>
	
   <a name="api_connectedhost"></a>
	<p class="Method_Heading"><font><font>-connectedHost</font></font></p>
	<p><font><font>该消息返回所连接的远程套接字作为一个字符串的IP地址。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （的NSString *）connectedHost</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>如果接收器连接，一个IP地址。</font></font></p>
			 <p><font><font>如果接收器未连接时，</font></font><span class="Constant"><font><font>零</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_connectedport"></a>
	<p class="Method_Heading"><font><font>-connectedPort</font></font></p>
	<p><font><font>该消息返回连接的远程套接字的端口号。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font> - （UINT16）connectedPort</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>如果接收器被连接，一个端口号。</font></font></p>
			 <p><font><font>如果接收器未连接时，</font></font><span class="Constant"><font><font>0</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_localhost"></a>
	<p class="Method_Heading"><font><font>-localhost</font></font></p>
	<p><font><font>该方法返回接收者作为一个字符串的本地IP地址。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font> - （的NSString *）本地主机</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>如果接收器连接，一个IP地址。</font></font></p>
			 <p><font><font>如果接收器未连接时，</font></font><span class="Constant"><font><font>零</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>如果计算机有多个IP地址，一个在使用的接收器将被退回。</font><font>如果计算机是在NAT之后，返回的IP地址将是一个局域网地址，而不是可用的局域网之外。</font></font></p>
	
   <a name="api_localport"></a>
	<p class="Method_Heading"><font><font>-localPort</font></font></p>
	<p><font><font>此方法返回接收器的端口号。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font> - （UINT16）本地端口</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>如果接收器被连接，一个端口号。</font></font></p>
			 <p><font><font>如果接收器未连接时，</font></font><span class="Constant"><font><font>0</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>如果计算机是在NAT之后，返回的端口号将是一个局域网地址，不准确局域网之外。</font></font></p>
	
   <a name="api_rw"></a>
	<h3><font><font>读取和写入信息</font></font></h3>
   <p><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatalengthtimeouttag"><font><font>-readDataToLength:withTimeout:tag: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatadatatimeouttag"><font><font>-readDataToData:withTimeout:tag: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatatimeouttag"><font><font>-readDataWithTimeout:tag: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_writedatatimeouttag"><font><font>-writeData:withTimeout:tag: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_progressreadtagbytesdonetotal"><font><font>-progressOfReadReturningTag:bytesDone:total: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_progresswritetagbytesdonetotal"><font><font>-progressOfWriteReturningTag:bytesDone:total:</font></font></a></p>
   
   <a name="api_readdatalengthtimeouttag"></a>
	<p class="Method_Heading"><font><font>-readDataToLength：withTimeout：标签：</font></font></p>
	<p><font><font>此消息队列读操作。</font><font>接收器将读取一定数量从插座字节。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）readDataToLength：（CFIndex）长withTimeout：（NSTimeInterval）超时标签：（长）标签</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="3"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>长度</font></font></p></td>
		<td>
			 <p><font><font>字节接收方应该读数。</font></font></p>
			 <p><font><font>如果</font></font><span class="Constant"><font><font>0</font></font></span><font><font>，接收器不执行任何操作，并不会发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>其委托。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>暂停</font></font></p></td>
		<td>
			 <p><font><font>秒从读出操作开始时的数目，其中该操作必须完成。</font><font>如果操作花费的时间超过此时间间隔，操作超时。</font></font></p>
			 <p><font><font>如果否定的，则读取操作不会超时。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>标签</font></font></p></td>
		<td>
			 <p><font><font>应用程序定义的整数或指针将被作为参数传递给</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>邮件发送到该委托。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
			 <p><font><font>接收器将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>对委托对象时的读操作已经完成。</font><font>接收到的数据将被传递作为消息的参数。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2">
			 <p><font><font>接收器将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>下列情况下，委托对象：</font></font></p>
			 <ul>
			<li><font><font>读操作超时。</font></font></li>
			<li><font><font>接收机从远程插座断开。</font></font></li>
			<li><font><font>发生其他I / O错误。</font></font></li>
			 </ul>
			 <p><font><font>该</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>方法可以检索部分通过发送接收数据</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatatimeouttag"><font><font>的标签：-readDataWithTimeout</font></font></a><font><font>套接字。</font></font></p>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>当字节已经成功接收，接收器就会发出</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>它的委托对象。</font></font></p>
	<p><font><font>读操作将被立即如果可能进行。</font><font>如果是，则接收机将从该方法返回之前发送消息。</font></font></p>
	
   <a name="api_readdatadatatimeouttag"></a>
	<p class="Method_Heading"><font><font>-readDataToData：withTimeout：标签：</font></font></p>
	<p><font><font>此消息队列读操作。</font><font>接收器将读取的字节，直到（并包括）在传递的字节序列</font></font><span class="Argument"><font><font>数据</font></font></span><font><font>的说法。</font><font>该序列作为一个分离器或分隔符。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）readDataToData：（NSData的*）数据withTimeout：（NSTimeInterval）超时标签：（长）标签</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="3"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>数据</font></font></p></td>
		<td>
			 <p><font><font>一个序列是标记的读操作的结束字节。</font></font></p>
			 <p><font><font>如果</font></font><span class="Constant"><font><font>为零</font></font></span><font><font>或空，接收器不执行任何操作，并不会发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>其委托。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>暂停</font></font></p>
		</td><td>
			 <p><font><font>秒从读出操作开始时的数目，其中该操作必须完成。</font><font>如果操作花费的时间超过此时间间隔，操作超时。</font></font></p>
			 <p><font><font>如果否定的，则读取操作不会超时。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>标签</font></font></p>
		</td><td>
			 <p><font><font>应用程序定义的整数或指针将被作为参数传递给</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>邮件发送到该委托。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
			 <p><font><font>接收器将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>对委托对象时的读操作已经完成。</font><font>接收到的数据将被传递作为消息的参数。</font><font>这将包括分隔符。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2">
			 <p><font><font>接收器将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>下列情况下，委托对象：</font></font></p>
			 <ul>
			<li><font><font>读操作超时。</font></font></li>
			<li><font><font>接收机从远程插座断开。</font></font></li>
			<li><font><font>发生其他I / O错误。</font></font></li>
			 </ul>
			 <p><font><font>该</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>方法可以检索部分通过发送接收数据</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatatimeouttag"><font><font>的标签：-readDataWithTimeout</font></font></a><font><font>套接字。</font></font></p>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>当字节已经成功接收，接收器就会发出</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>它的委托对象，通过所有接收的字节数作为参数，包括分隔序列。</font></font></p>
	<p><font><font>读操作将被立即如果可能进行。</font><font>如果是，则接收机将从该方法返回之前发送消息。</font></font></p>
	<p><font><font>注意，此方法不是字符集感知。</font><font>如果一个字符应该发生要被编码到相匹配的定界序列字节序列，读取操作可以过早地结束。</font></font></p>
	
   <a name="api_readdatatimeouttag"></a>
	<p class="Method_Heading"><font><font>-readDataWithTimeout：标签：</font></font></p>
	<p><font><font>此消息队列读操作。</font><font>接收器将检索第一个可用的字节。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）readDataWithTimeout：（NSTimeInterval）超时标签：（长）标签</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="2"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>暂停</font></font></p></td>
		<td>
			 <p><font><font>
			 	秒从读出操作开始时的数目，其中该操作必须完成。</font><font>如果操作花费的时间超过此时间间隔，操作超时。
			 </font></font></p>
			 <p><font><font>如果否定的，则读取操作不会超时。</font></font></p>
		</td>
		</tr>
		
		<tr>
		<td class="Argument"><p><font><font>标签</font></font></p></td>
		<td>
			 <p><font><font>应用程序定义的整数或指针将被作为参数传递给</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>邮件发送到该委托。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
			 <p><font><font>
			 	接收器将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font>其委托对象时，读操作已经完成。</font><font>接收到的数据，如果有的话，将被作为参数传递。
			 </font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2">
			 <p><font><font>会发生错误在这些条件下：</font></font></p>
			 <ul>
			<li><font><font>读操作超时。</font></font></li>
			<li><font><font>接收机从远程插座断开。</font></font></li>
			<li><font><font>发生其他I / O错误。</font></font></li>
			 </ul>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>
		当字节已经成功取回，接收器将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a><font><font> 
		它的委托对象，通过所有接收的字节数作为参数。
	</font></font></p>
	
	<a name="api_writedatatimeouttag"></a>
	<p class="Method_Heading"><font><font>-writeData：withTimeout：标签：</font></font></p>
	<p><font><font>此消息队列写操作。</font><font>接收器将写入一个</font></font><span class="Class"><font><font>NSData的</font></font></span><font><font>对象插座。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）writeData：（NSData的*）数据withTimeout：（NSTimeInterval）超时标签：（长）标签</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="3"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>数据</font></font></p></td>
		<td>
			 <p><font><font>应写入到远程套接字的数据。</font></font></p>
			 <p><font><font>如果</font></font><span class="Constant"><font><font>为零</font></font></span><font><font>，接收器不执行任何操作，并不会发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidwritedatatag"><font><font>-onSocket：didWriteDataWithTag：</font></font></a><font><font>其委托。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>暂停</font></font></p></td>
		<td>
			 <p><font><font>秒从写操作的开始的数，其中该操作必须完成。</font><font>如果操作花费的时间超过此时间间隔，操作超时。</font></font></p>
			 <p><font><font>如果否定的，则写操作不会超时。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>标签</font></font></p></td>
		<td>
			 <p><font><font>应用程序定义的整数或指针将被作为参数传递给</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidwritedatatag"><font><font>-onSocket：didWriteDataWithTag：</font></font></a><font><font>邮件发送到该委托。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
			 <p><font><font>无。</font><font>接收器将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidwritedatatag"><font><font>-onSocket：didWriteDataWithTag：</font></font></a><font><font>对委托对象时的写操作已经完成。 
		</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2">
			 <p><font><font>接收器将发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>下列情况下，委托对象：</font></font></p>
			 <ul>
			<li><font><font>写操作超时。</font></font></li>
			<li><font><font>接收机从远程插座断开。</font></font></li>
			<li><font><font>发生其他I / O错误。</font></font></li>
			 </ul>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>当字节已经成功发送，接收器就会发出</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidwritedatatag"><font><font>-onSocket：didWriteData：withTag：</font></font></a><font><font>它的委托对象。</font></font></p>
	<p><font><font>写操作将立即如果可能进行。</font><font>如果是，则接收机将从该方法返回之前发送消息。</font></font></p>

	<a name="api_progressreadtagbytesdonetotal"></a>
	<p class="Method_Heading"><font><font>-progressOfReadReturningTag：bytesDone：总：</font></font></p>
	<p><font><font>该消息可以被发送到确定当前的读操作的进度。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （浮点）progressOfReadReturningTag：（长*）标记bytesDone：（CFIndex *）完成总：（CFIndex *）总</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="3"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>标签</font></font></p></td>
		<td>
			<p><font><font>一个变量的地址。</font><font>当此方法返回时，变量将包含当前的读操作的标签。</font><font>如果没有当前的读操作，该变量将不会被改变。</font></font></p>
			 <p><font><font>发送者可以通过</font></font><span class="Constant"><font><font>空</font></font></span><font><font>，如果它不希望检索标签。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>做完</font></font></p></td>
		<td>
			 <p><font><font>一个变量的地址。</font><font>当此方法返回，变量将包含当前的读操作已读的字节数。</font><font>如果没有当前的读操作，该变量将不会被改变。</font></font></p>
			 <p><font><font>发送方可以通过</font></font><span class="Constant"><font><font>空</font></font></span><font><font>，如果它不希望检索读的字节数。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>总</font></font></p></td>
		<td>
			 <p><font><font>一个变量的地址。</font><font>当此方法返回，变量将包含当前的读操作期望读取的字节的总数。</font><font>这个值是唯一有意义的，如果当前的读操作是一个“读与长度”操作。</font><font>如果没有当前的读操作，该变量将不会被改变。</font></font></p>
			 <p><font><font>发送方可以通过</font></font><span class="Constant"><font><font>空</font></font></span><font><font>，如果它不希望检索所读取的字节的总数。</font></font></p>
		</td></tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
			 <p><font><font>十进制值。</font></font></p>
			 <ul>
				<li><span class="Constant"><font><font>为NaN</font></font></span><font><font>表明存在当前正在执行没有读操作。</font><font>使用</font></font><span class="Function"><font><font>isnan（）</font></font></span><font><font>函数来测试这种返回值。</font></font></li>
				<li><span class="Constant"><font><font>0.0</font></font></span><font><font>表示没有字节被读取的份额。</font></font></li>
				<li><span class="Constant"><font><font>1.0</font></font></span><font><font>表示所有字节已被读出的总和，或字节的总数必须读取是不知道的。</font></font></li>
			</ul>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2"><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	
	<a name="api_progresswritetagbytesdonetotal"></a>
	<p class="Method_Heading"><font><font>-progressOfWriteReturningTag：bytesDone：总：</font></font></p>
	<p><font><font>该消息可以被发送到确定当前的写操作的进度。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （浮点）progressOfWriteReturningTag（长*）标记bytesDone：（CFIndex *）完成总：（CFIndex *）总</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="3"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>标签</font></font></p></td>
		<td>
			<p><font><font>一个变量的地址。</font><font>当此方法返回时，变量将包含当前的读操作的标签。</font><font>如果没有当前的读操作，该变量将不会被改变。</font></font></p>
			 <p><font><font>发送者可以通过</font></font><span class="Constant"><font><font>空</font></font></span><font><font>，如果它不希望检索标签。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>做完</font></font></p></td>
		<td>
			 <p><font><font>一个变量的地址。</font><font>当此方法返回，变量将包含已发送的字节数。</font><font>如果没有当前的读操作，该变量将不会被改变。</font></font></p>
			 <p><font><font>发送方可以通过</font></font><span class="Constant"><font><font>空</font></font></span><font><font>，如果它不希望检索发送的字节的数目。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>总</font></font></p></td>
		<td>
			 <p><font><font>一个变量的地址。</font><font>当此方法返回，变量将包含的字节的当前写操作被发送的总数。</font><font>如果没有当前的读操作，该变量将不会被改变。</font></font></p>
			 <p><font><font>发送方可以通过</font></font><span class="Constant"><font><font>空</font></font></span><font><font>，如果它不希望检索所发送的字节总数。</font></font></p>
		</td></tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
			 <p><font><font>十进制值。</font></font></p>
			 <ul>
				<li><span class="Constant"><font><font>为NaN</font></font></span><font><font>表明存在当前正在执行不写入操作。</font><font>使用</font></font><span class="Function"><font><font>isnan（）</font></font></span><font><font>函数来测试这种返回值。</font></font></li>
				<li><span class="Constant"><font><font>0.0</font></font></span><font><font>表示没有字节已发送总量。</font></font></li>
				<li><span class="Constant"><font><font>1.0</font></font></span><font><font>表示所有字节已发送总量的。</font></font></li>
			</ul>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td colspan="2"><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_delim"></a>
	<h3><font><font>定界符消息</font></font></h3>
	<p><font><font>这些消息的结果是可以传递的常用分隔符</font></font><span class="Argument"><font><font>数据</font></font></span><font><font>的一个论点</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatadatatimeouttag"><font><font>-readDataToData：withTimeout：标签：</font></font></a><font><font>消息。</font></font></p>
   <p><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_crlfdata"><font><font>+ CRLFData </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_crdata"><font><font>+ CRData </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_lfdata"><font><font>+ LFDATA </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_zerodata"><font><font>+ ZeroData</font></font></a></p>
   
   <a name="api_crlfdata"></a>
	<p class="Method_Heading"><font><font>+ CRLFData</font></font></p>
	<p><font><font>此方法返回CRLF字节序列，行分隔符为DOS和Windows。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font>+（NSData的*）CRLFData</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>的一个实例</font></font><span class="Class"><font><font>的NSData</font></font></span><font><font>含有字节</font></font><span class="Constant"><font><font>0D0A</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	
   <a name="api_crdata"></a>
	<p class="Method_Heading"><font><font>+ CRData</font></font></p>
	<p><font><font>此方法返回CR字节序列，Mac OS X的前行分隔的Macintosh操作系统</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font>+（NSData的*）CRData</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>的一个实例</font></font><span class="Class"><font><font>的NSData</font></font></span><font><font>包含该字节</font></font><span class="Constant"><font><font>0D</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_lfdata"></a>
	<p class="Method_Heading"><font><font>+ LFDATA</font></font></p>
	<p><font><font>此方法返回的LF字节序列，行分隔符为大多数Unix操作系统和Mac OS X.</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font>+（NSData的*）LFDATA</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>的一个实例</font></font><span class="Class"><font><font>的NSData</font></font></span><font><font>包含该字节</font></font><span class="Constant"><font><font>0A</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_zerodata"></a>
	<p class="Method_Heading"><font><font>+ ZeroData</font></font></p>
	<p><font><font>该方法返回一个零字节，分隔符为C字符串。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font>+（NSData的*）ZeroData</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>的一个实例</font></font><span class="Class"><font><font>的NSData</font></font></span><font><font>包含该字节</font></font><span class="Constant"><font><font>00</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>

   <a name="api_debug"></a>
	<h3><font><font>调试和自定义消息</font></font></h3>
   <p><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_description"><font><font>-description </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_getcfsocket"><font><font>-getCFSocket </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_getcfreadstream"><font><font>-getCFReadStream </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_getcfwritestream"><font><font>-getCFWriteStream</font></font></a></p>
	
   <a name="api_description"></a>
	<p class="Method_Heading"><font><font>-description</font></font></p>
	<p><font><font>该消息返回适用于调试目的接收机的描述。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font> - （的NSString *）的说明</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td><p><font><font>描述了接收器和其地位的字符串。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>返回的描述不具有任何新行字符，并包括：</font></font></p>
	<ul>
		<li><font><font>接收机的id /地址和散列值。</font></font></li>
		<li><font><font>一个</font></font><span class="Class"><font><font>CFSocket</font></font></span><font><font>参考号。</font></font></li>
		<li><font><font>本地和远程套接字地址。</font></font></li>
		<li><font><font>排队读，写操作的次数。</font></font></li>
		<li><font><font>目前的读取和写入操作的进度。</font></font></li>
		<li><span class="Class"><font><font>CFReadStream</font></font></span><font><font>和</font></font><span class="Class"><font><font>CFWriteStream</font></font></span><font><font>参考号码。</font></font></li>
		<li><font><font>的读取和写入流的状态。</font></font></li>
		<li><font><font>的连接状态。</font></font></li>
	</ul>
	
   <a name="api_getcfsocket"></a>
	<p class="Method_Heading"><font><font>-getCFSocket</font></font></p>
	<p><font><font>该消息返回内部</font></font><span class="Class"><font><font>CFSocket</font></font></span><font><font>使用由接收器的实例是，使访问底层Unix套接字。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font> - （CFSocketRef）getCFSocket</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>接收器的</font></font><span class="Class"><font><font>CFSocket</font></font></span><font><font>参考号码，或</font></font><span class="Constant"><font><font>NULL</font></font></span><font><font>如果没有连接或接受连接。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>不要关闭，读取或写入底层套接字。</font></font></p>

   <a name="api_getcfreadstream"></a>
	<p class="Method_Heading"><font><font>-getCFReadStream</font></font></p>
	<p><font><font>此方法返回内部</font></font><span class="Class"><font><font>CFReadStream</font></font></span><font><font>使用由接收器的实例是，使访问底层碳流。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font> - （CFReadStreamRef）getCFReadStream</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>接收器的</font></font><span class="Class"><font><font>CFReadStream</font></font></span><font><font>参考号码，或</font></font><span class="Constant"><font><font>NULL</font></font></span><font><font>如果没有连接或接受连接。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>不要关闭，读取或写入底层流。</font></font></p>

   <a name="api_getcfwritestream"></a>
	<p class="Method_Heading"><font><font>-getCFWriteStream</font></font></p>
	<p><font><font>此方法返回内部</font></font><span class="Class"><font><font>CFWriteStream</font></font></span><font><font>正在使用的接收机实例，从而可以访问底层的碳流。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>句法</font></font></p></th>
		<td class="Code"><p><font><font> - （CFWriteStreamRef）getCFWriteStream</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td>
			 <p><font><font>接收器的</font></font><span class="Class"><font><font>CFWriteStream</font></font></span><font><font>参考号码，或</font></font><span class="Constant"><font><font>NULL</font></font></span><font><font>如果没有连接或接受连接。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>错误</font></font></p></th>
		<td><p><font><font>无。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>不要关闭，读取或写入底层流。</font></font></p>

   <a name="api_delegmeth"></a>
	<h3><font><font>AsyncSocketDelegate方法</font></font></h3>
	<p><font><font>委托对象可以实现这些方法来应对</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>消息。</font></font></p>
   <p><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket:willDisconnectWithError: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdiddisconnect"><font><font>-onSocketDidDisconnect: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidacceptnewsock"><font><font>-onSocket:didAcceptNewSocket: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwantsrunloopnewsock"><font><font>-onSocket:wantsRunLoopForNewSocket: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwillconnect"><font><font>-onSocketWillConnect: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidconnecthostport"><font><font>-onSocket:didConnectToHost:port: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket:didReadData:withTag: </font></font></a> <a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidwritedatatag"><font><font>-onSocket:didWriteDataWithTag:</font></font></a></p>
	
   <a name="api_sockwilldisconnecterror"></a>
	<p class="Method_Heading"><font><font>-onSocket：willDisconnectWithError：</font></font></p>
	<p><font><font>在出现错误的情况下，该插座被断开。</font><font>插座断开连接之前发送此消息。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>原型</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）onSocket：（AsyncSocket *）袜子willDisconnectWithError：（NSError *）ERR</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="2"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>袜子</font></font></p></td>
		<td>
			 <p><font><font>发送</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>实例。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>犯错</font></font></p></td>
		<td>
			 <p><font><font>的错误造成的插座断开连接。</font></font></p>
			 <p><font><font>如果</font></font><span class="Constant"><font><font>为零</font></font></span><font><font>，则没有错误。</font><font>这通常意味着套接字被干净地由远程客户端应用程序关闭。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>条件</font></font></p></th>
		<td colspan="2">
			 <p><font><font>此消息被发送：</font></font></p>
			 <ul>
			<li><font><font>如果有一个连接，超时，或者其他I / O错误。</font></font></li>
			<li><font><font>如果远程插座干净断开。</font></font></li>
			<li><font><font>前本地套接字被断开。</font></font></li>
			 </ul>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>此消息的主要目的是给接收机有机会从连接检索任何剩余的缓存数据。</font><font>该接收器可以做到这一点通过发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatatimeouttag"><font><font>-readDataWithTimeout：标签：</font></font></a><font><font>给发件人。</font></font></p>
	
   <a name="api_sockdiddisconnect"></a>
	<p class="Method_Heading"><font><font>-onSocketDidDisconnect：</font></font></p>
	<p><font><font>插座发送此消息被称为后它已断开。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>原型</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）onSocketDidDisconnect：（AsyncSocket *）袜</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>袜子</font></font></p></td>
		<td>
			 <p><font><font>发送</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>实例。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>条件</font></font></p></th>
		<td colspan="2"><p><font><font>发件人断开以任何理由后，此消息被发送。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>接收器可以安全地释放寄件人在此方法。</font></font></p>

   <a name="api_sockdidacceptnewsock"></a>
	<p class="Method_Heading"><font><font>-onSocket：didAcceptNewSocket：</font></font></p>
	<p><font><font>插座将此消息发送到接收器提供了机会，以节省一个新的socket的适当位置。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>原型</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）onSocket：（AsyncSocket *）袜子didAcceptNewSocket：（AsyncSocket *）newSocket</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="2"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>袜子</font></font></p></td>
		<td>
			 <p><font><font>发送</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>实例。</font><font>这个实例将接受连接。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>newSocket</font></font></p></td>
		<td>
			 <p><font><font>的新实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>条件</font></font></p></th>
		<td colspan="2">
			 <p><font><font>发件人接受传入连接，并创建一个新的实例之后，此方法被发送</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>来处理它。</font></font></p>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>当这个消息被发送，</font></font><span class="Argument"><font><font>newSocket</font></font></span><font><font>未完全连接到远程套接字。</font></font></p>
	<p><font><font>接收机应该分配和保留</font></font><span class="Argument"><font><font>newSocket</font></font></span><font><font>，并且还可以设置一个更合适的委托。</font></font></p>
	
   <a name="api_sockwantsrunloopnewsock"></a>
	<p class="Method_Heading"><font><font>-onSocket：wantsRunLoopF​​orNewSocket：</font></font></p>
	<p><font><font>插座发送此消息，以确定哪些线程和运行循环的新的socket及其委托的方法应该进行操作。</font><font>默认为当前运行循环。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>原型</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （NSRunLoop *）onSocket：（AsyncSocket *）袜子wantsRunLoopF​​orNewSocket：（AsyncSocket *）newSocket</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="2"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>袜子</font></font></p></td>
		<td>
			 <p><font><font>发送</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>实例。</font><font>这个实例将接受连接。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>newSocket</font></font></p></td>
		<td>
			 <p><font><font>的一个实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
         <p><font><font>实例</font></font><span class="Class"><font><font>NSRunLoop</font></font></span><font><font>与目标线程关联。</font></font></p>
      </td>
		</tr>
		<tr>
		<th><p><font><font>条件</font></font></p></th>
		<td colspan="2">
			 <p><font><font>发件人接受传入连接，并发送所述后本方法发送</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidacceptnewsock"><font><font>didAcceptNewSocket：-onSocket</font></font></a><font><font>消息。</font></font></p>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>当这个消息被发送，</font></font><span class="Argument"><font><font>newSocket</font></font></span><font><font>未完全连接到远程套接字。</font></font></p>
	<p><font><font>接收机应返回的实例</font></font><span class="Class"><font><font>NSRunLoop</font></font></span><font><font>与目标线程相关联。</font><font>从所有代表消息</font></font><span class="Argument"><font><font>newSocket</font></font></span><font><font>将在该线程到运行循环的上下文中被发送，所有定时器将运行在该运行循环，而将出现在该线程的所有处理。</font></font></p>
	<p><font><font>如果接收机不实现此方法中，发送者将使用当前线程和运行循环。</font></font></p>

   <a name="api_sockwillconnect"></a>
	<p class="Method_Heading"><font><font>-onSocketWillConnect：</font></font></p>
	<p><font><font>套接字发送此消息时，它是将要连接到远程套接字。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>原型</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （BOOL）onSocketWillConnect：（AsyncSocket *）袜</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>争论</font></font></p></th>
		<td class="Argument"><p><font><font>袜子</font></font></p></td>
		<td><p><font><font>发件人。</font></font></p></td>
		</tr>
		<tr>
		<th><p><font><font>返回值</font></font></p></th>
		<td colspan="2">
			<p><span class="Constant"><font><font>是</font></font></span><font><font>如果套接字应继续连接到远程套接字。</font><font>这是默认如果此方法不是由接收器来实现。</font></font></p>
			<p><span class="Constant"><font><font>NO</font></font></span><font><font>取消连接。</font></font></p>
		</td>
		</tr>
		<tr><th><p><font><font>条件</font></font></p></th>
		<td colspan="2">
			 <p><font><font>发送者尝试连接到之前这个消息发送：</font></font></p>
			 <ul>
			<li><font><font>由指定的远程插座</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>onPort：错误：-connectToHost</font></font></a><font><font>消息。</font></font></li>
			<li><font><font>发起于由指定的端口连接的远程套接字</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>错误：-acceptOnPort</font></font></a><font><font>消息。
			</font></font></li><li><font><font>发起到由指定的地址和端口的连接的远程套接字</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptaddressporterror"><font><font>端口：错误：-acceptOnAddress</font></font></a><font><font>消息。</font></font></li>
			 </ul>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>此消息主要是为了给接收器中的机会来配置内部的属性</font></font><span class="Class"><font><font>CFReadStream</font></font></span><font><font>或</font></font><span class="Class"><font><font>CFWriteStream</font></font></span><font><font>实例。</font><font>接收机应该返回</font></font><span class="Constant"><font><font>YES</font></font></span><font><font>或</font></font><span class="Constant"><font><font>NO</font></font></span><font><font>，指示发送者是否应继续连接。</font></font></p>
	<p><font><font>如果接收器返回</font></font><span class="Constant"><font><font>NO</font></font></span><font><font>，连接尝试发起</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/api_connecthostporterror"><font><font>-connectToHost：onPort：错误：</font></font></a><font><font>，该方法将返回</font></font><span class="Constant"><font><font>NO</font></font></span><font><font>其发送者，以及一个</font></font><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdomain"><font><font>AsyncSocketCanceledError</font></font></a><font><font>错误对象。</font></font></p>
	<p><font><font>如果接收机返回</font></font><span class="Constant"><font><font>否</font></font></span><font><font>，且连接尝试通过远程套接字发起的，将报告任何错误。</font></font></p> 

   <a name="api_sockdidconnecthostport"></a>
	<p class="Method_Heading"><font><font>-onSocket：didConnectToHost：端口：</font></font></p>
	<p><font><font>插座发送此消息它是连接并准备读取或写入时。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>原型</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）onSocket：（AsyncSocket *）袜子didConnectToHost：（*的NSString）主机端口：（UINT16）端口</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="3"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>袜子</font></font></p></td>
		<td><p><font><font>发件人。</font></font></p></td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>主持人</font></font></p></td>
		<td>
			 <p><font><font>远程套接字的IPv4或IPv6地址。</font></font></p>
			 <p><font><font>这可能不同于发送到发送者的IP地址或DNS名称</font></font><span class="Argument"><font><font>主机</font></font></span><font><font>的参数</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>-connectToHost：onPort：错误：</font></font></a><font><font>。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>港</font></font></p>
		</td><td>
			 <p><font><font>远程套接字的端口。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>条件</font></font></p></th>
		<td colspan="2">
			 <p><font><font>此消息发出后发送已成功连接到：</font></font></p>
			 <ul>
			<li><font><font>由指定的远程插座</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>onPort：错误：-connectToHost</font></font></a><font><font>消息。</font></font></li>
			<li><font><font>发起于由指定的端口连接的远程套接字</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>错误：-acceptOnPort</font></font></a><font><font>消息。
			</font></font></li><li><font><font>发起到由指定的地址和端口的连接的远程套接字</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptaddressporterror"><font><font>端口：错误：-acceptOnAddress</font></font></a><font><font>消息。</font></font></li>
			 </ul>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>接收机可以选择断开发件人，或排队的读或写操作。</font></font></p>
	<p><font><font>从这个方法的接收机返回后，插座将执行任何先前排队的读或写操作。</font></font></p>
	
   <a name="api_sockdidreaddatatag"></a>
	<p class="Method_Heading"><font><font>-onSocket：didReadData：withTag：</font></font></p>
	<p><font><font>发送端发送此消息时，它成功完成读操作。</font><font>它可以被调用read方法返回，或更高版本之前发送该消息。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>原型</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）onSocket：（AsyncSocket *）袜子didReadData：（NSData的*）数据withTag：（长）标签</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="3"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>袜子</font></font></p></td>
		<td><p><font><font>发件人。</font></font></p></td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>数据</font></font></p></td>
		<td>
			 <p><font><font>所接收的数据。</font></font></p>
		</td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>标签</font></font></p></td>
		<td>
			 <p><font><font>该</font></font><span class="Argument"><font><font>标签</font></font></span><font><font>在读取邮件传递的参数。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>条件</font></font></p></th>
		<td colspan="2">
			 <p><font><font>这个消息被发送后发送方已经成功地接收到请求的数据。</font></font></p></td>
		</tr>
	</tbody></table>
	<p><font><font>如果读操作失败，发送者会发送一个</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>消息代替。</font></font></p>
	<p><font><font>接收机应该处理的数据和队列读或根据需要写入操作或断开。</font></font></p>
	
   <a name="api_sockdidwritedatatag"></a>
	<p class="Method_Heading"><font><font>-onSocket：didWriteDataWithTag：</font></font></p>
	<p><font><font>发送端发送此消息时，一个写操作已成功完成。</font><font>它可能会发送此消息之前，调用write方法返回，或更高版本。</font></font></p>
	<table>
		<tbody><tr>
		<th><p><font><font>原型</font></font></p></th>
		<td class="Code" colspan="2"><p><font><font> - （无效）onSocket：（AsyncSocket *）袜子didWriteDataWithTag：（长）标签</font></font></p></td>
		</tr>
		<tr>
		<th rowspan="2"><p><font><font>参数</font></font></p></th>
		<td class="Argument"><p><font><font>袜子</font></font></p></td>
		<td><p><font><font>发件人。</font></font></p></td>
		</tr>
		<tr>
		<td class="Argument"><p><font><font>标签</font></font></p></td>
		<td>
			 <p><font><font>该</font></font><span class="Argument"><font><font>标签</font></font></span><font><font>中写入信息传递的参数。</font></font></p>
		</td>
		</tr>
		<tr>
		<th><p><font><font>条件</font></font></p></th>
		<td colspan="2">
			 <p><font><font>此消息发出后发送方发送成功所提供的数据。</font></font></p>
		</td>
		</tr>
	</tbody></table>
	<p><font><font>如果一个写操作是不成功的，发送者会发送一个</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>消息代替。</font></font></p>
	<p><font><font>接收方应排队读或根据需要写操作或断开。</font></font></p>
	
   <a name="api_err"></a>
   <h3><font><font>错误</font></font></h3>
   
   <a name="api_sockexception"></a>
	<p class="Method_Heading"><font><font>AsyncSocketException</font></font></p>
	<p><font><font>实例</font></font><span class="Class"><font><font>AsyncSocket</font></font></span><font><font>引发此异常时，它收到一个</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>-acceptOnPort：错误：</font></font></a><font><font>，</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptaddressporterror"><font><font>-acceptOnAddress：端口：错误：</font></font></a><font><font>或</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>-connectToHost：onPort：错误：</font></font></a><font><font>消息，并且：</font></font></p>
	<ul>
		<li><font><font>它已经连接或接受连接的。</font></font></li>
		<li><font><font>它没有被分配委托。</font></font></li>
	</ul>
	
   <a name="api_sockdomain"></a>
	<p class="Method_Heading"><font><font>AsyncSocketErrorDomain</font></font></p>
	<p><font><font>这</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>域包括以下</font></font><span class="Class"><font><font>AsyncSocketError</font></font></span><font><font>代码：</font></font></p>
   <ul>
      <li><p><span class="Constant"><font><font>AsyncSocketCanceledError</font></font></span><font><font>表明一个套接字的</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwillconnect"><font><font>-onSocketWillConnect：</font></font></a><font><font>委托方法返回</font></font><span class="Constant"><font><font>NO</font></font></span><font><font>。</font><font>它是由一个返回</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>onPort：错误：-connectToHost</font></font></a><font><font>消息。</font></font></p></li>
      <li><p><span class="Constant"><font><font>AsyncSocketCFSocketError</font></font></span><font><font>表示在一个错误</font></font><span class="Class"><font><font>CFSocket</font></font></span><font><font>操作。</font><font>虽然接受传入的连接或建立传出连接，并且可以通过一个非法的端口号或一个内部错误而引起可能出现这样的错误。</font><font>它一般由返回</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>-acceptOnPort：错误：</font></font></a><font><font>，</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptaddressporterror"><font><font>-acceptOnAddress：端口：错误：</font></font></a><font><font>或</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>-connectToHost：onPort：错误：</font></font></a><font><font>消息。</font></font></p></li>
      <li><p><span class="Constant"><font><font>AsyncSocketReadTimeoutError</font></font></span><font><font>表示读取操作已超时。</font><font>它被传递给一个插座的委托在</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>消息。</font></font></p></li>
      <li><p><span class="Constant"><font><font>AsyncSocketWriteTimeoutError</font></font></span><font><font>表明一个写操作已超时。</font><font>它被传递给一个插座的委托在</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a><font><font>消息。</font></font></p></li>
      <li><p><span class="Constant"><font><font>AsyncSocketNoError</font></font></span><font><font>，表示没有错误，从未使用过。</font><font>它被定义为完整起见。</font></font></p></li>
   </ul>
   <p><font><font>您可以提供在这些代码本地化错误消息</font></font><span class="Filename "><font><font>AsyncSocket.strings</font></font></span><font><font>串在主包文件，用作键“AsyncSocketNoError，” </font></font><i><font><font>等</font></font></i><font><font>默认提供英文字符串。</font></font></p>
   
    <a name="new"></a>
    <h2><font><font>API更改</font></font></h2>
	<p><font><font>因为AsyncSocket 4.2的变化：</font></font></p>
	<ul>
		<li><p><font><font>每个套接字</font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_ud"><font><font>的用户数据</font></font></a><font><font> ​​已经被添加。</font></font></p></li>
		<li><p><span class="Function"><font><font>-readDataWithTag：</font></font></span><font><font>已取代</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatatimeouttag"><font><font>-readDataWithTimeout：标签：</font></font></a><font><font>。</font><font>通过这种方法不会返回空数据</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>didReadData：withTag：-onSocket</font></font></a><font><font>委托方法，但反而会推迟，直到数据到达。</font><font>的新方法仍然可以用于从内恢复未读出数据</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError： </font></font></a><font><font>。</font></font></p></li>
	</ul>
	<p><font><font>因为AsyncSocket 4.0的变化：</font></font></p>
	<ul>
		<li><p><font><font>两个方法已经被添加到允许您监视当前</font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_progressreadtagbytesdonetotal"><font><font>读取</font></font></a><font><font>和</font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_progresswritetagbytesdonetotal"><font><font>写入</font></font></a><font><font>操作。</font></font></p></li>
		<li><p><font><font>一个</font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptaddressporterror"><font><font>新的方法，</font></font></a><font><font>使得socket只接受在一个地址的连接。</font></font></p></li>
        <li><p><font><font>阿</font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwillconnect"><font><font>新的委托方法</font></font></a><font><font>已被添加到允许底层流和</font></font><span class="Class"><font><font>CFSocket</font></font></span><font><font>进行定制。</font></font></p></li>
		<li><p><font><font>一个</font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdomain"><font><font>错误代码</font></font></a><font><font>已被添加到支持该方法。</font></font></p></li>
	</ul>

    <p><font><font>因为AsyncSocket 3.13的变化：</font></font></p>
    <ul>
		<li><p><font><font>AsyncSocket现在需要Mac OS X 10.4或更高版本。</font></font></p></li>
        <li><p><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>-acceptOnPort：</font></font></a><font><font>和</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>-connectToHost：onPort：</font></font></a><font><font>现在需要一个额外的误差参数。</font><font>这可以设置为</font></font><span class="Constant"><font><font>无</font></font></span><font><font>，如果你不感兴趣，此功能。</font></font></p></li>
        <li><p><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>-acceptOnPort：</font></font></a><font><font>和</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>-connectToHost：onPort：</font></font></a><font><font>还引发</font></font><a href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockexception"><font><font>异常</font></font></a><font><font>如果使用，而不是返回时已经连接或接受连接套接字，</font></font><span class="Constant"><font><font>NO</font></font></span><font><font>。</font></font></p></li>
        <li><p><font><font>该</font></font><span class="Argument"><font><font>错误</font></font></span><font><font>的说法</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>willDisconnectWithError：-onSocket</font></font></a><font><font>现在是一个</font></font><span class="Class"><font><font>NSError</font></font></span><font><font>对象，而不是</font></font><span class="Class"><font><font>CFStreamError</font></font></span><font><font>对象。</font></font></p></li>
        <li><p><font><font>一个</font></font><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwantsrunloopnewsock"><font><font>新的委托方法</font></font></a><font><font>已被添加到处理传入的连接线程。</font></font></p></li>
        <li><p><span class="Function"><font><font>+ addressFromString：</font></font></span><font><font>已被删除。</font><font>使用</font></font><span class="Class"><font><font>CFHost</font></font></span><font><font>或</font></font><span class="Class"><font><font>NSHost</font></font></span><font><font>代替。</font></font></p></li>
        <li><p><font><font>现在可以区分引起从那些引起写入超时一个读超时中断。</font></font></p></li>
        <li><p><font><font>您必须添加</font></font><span class="Filename "><font><font>/System/Library/Frameworks/CoreServices.framework</font></font></span><font><font>到项目; </font><font>这是必要的，以一定的CFStreamError域转换成NSError域。</font></font></p></li>
    </ul>
   
   <a name="idx"></a>
   <h2><font><font>API指数</font></font></h2>
   <ul>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptaddressporterror"><font><font>-acceptOnAddress：端口：错误：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_acceptporterror"><font><font>-acceptOnPort：错误：</font></font></a></li>
      <li><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdomain"><font><font>AsyncSocketCanceledError</font></font></a></li>
      <li><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdomain"><font><font>AsyncSocketCFSocketError</font></font></a></li>
      <li><a class="Class" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdomain"><font><font>AsyncSocketError</font></font></a></li>
      <li><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdomain"><font><font>AsyncSocketErrorDomain</font></font></a></li>
      <li><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockexception"><font><font>AsyncSocketException</font></font></a></li>
      <li><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdomain"><font><font>AsyncSocketNoError</font></font></a></li>
      <li><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdomain"><font><font>AsyncSocketReadTimeoutError</font></font></a></li>
      <li><a class="Constant" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdomain"><font><font>AsyncSocketWriteTimeoutError</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_cansafelysetdelegate"><font><font>-canSafelySetDelegate</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connectedhost"><font><font>-connectedHost</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connectedport"><font><font>-connectedPort</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_connecthostporterror"><font><font>-connectToHost：onPort：错误：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_crdata"><font><font>+ CRData</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_crlfdata"><font><font>+ CRLFData</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_dealloc"><font><font>-dealloc</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_delegate"><font><font>-delegate</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_description"><font><font>-description</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_disconnect"><font><font class="">-disconnect</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_disconnectafterwriting"><font><font>-disconnectAfterWriting</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_getcfreadstream"><font><font>-getCFReadStream</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_getcfsocket"><font><font>-getCFSocket</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_getcfwritestream"><font><font>-getCFWriteStream</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_init"><font><font>-init</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_initdelegate"><font><font>-initWithDelegate：</font></font></a></li>
	  <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_initdelegateuserdata"><font><font>-initWithDelegate：USERDATA：</font></font></a></li>
	  <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_isconnected"><font><font>-isConnected</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_lfdata"><font><font>+ LFDATA</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_localhost"><font><font>-localhost</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_localport"><font><font>-localPort</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidacceptnewsock"><font><font>-onSocket：didAcceptNewSocket：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidconnecthostport"><font><font>-onSocket：didConnectToHost：端口：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdiddisconnect"><font><font>-onSocketDidDisconnect：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidreaddatatag"><font><font>-onSocket：didReadData：withTag：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockdidwritedatatag"><font><font>-onSocket：didWriteDataWithTag：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwantsrunloopnewsock"><font><font>-onSocket：wantsRunLoopF​​orNewSocket：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwillconnect"><font><font>-onSocketWillConnect：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_sockwilldisconnecterror"><font><font>-onSocket：willDisconnectWithError：</font></font></a></li>
	  <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_progressreadtagbytesdonetotal"><font><font class="">-progressOfReadReturningTag：bytesDone：总：</font></font></a></li>
	  <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_progresswritetagbytesdonetotal"><font><font>-progressOfWriteReturningTag：bytesDone：总：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatadatatimeouttag"><font><font>-readDataToData：withTimeout：标签：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatalengthtimeouttag"><font><font>-readDataToLength：withTimeout：标签：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_readdatatimeouttag"><font><font>-readDataWithTimeout：标签：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_setdelegate"><font><font>-setDelegate：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_setuserdata"><font><font>-setUserData：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_userdata"><font><font>-userData</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_writedatatimeouttag"><font><font>-writeData：withTimeout：标签：</font></font></a></li>
      <li><a class="Function" href="file:///Users/xiao/Downloads/asyncsocket-example-master/cocoaasyncsocket-read-only/AsyncSocket%20Documentation.html#api_zerodata"><font><font>+ ZeroData</font></font></a></li>
   </ul>

   <hr>
   <center><cite><font><font>作者：达斯汀沃斯</font></font></cite></center><div id="goog-gt-tt" class="goog-tooltip skiptranslate" dir="ltr" style="visibility: hidden; left: 132px; top: 558.5625px; display: none;"><div style="padding: 8px;"><div><div class="logo"><img src="./文档_files/translate-32.png" width="20" height="20"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">原文</h1></div><div class="middle" style="padding: 8px;"><div class="original-text">-disconnect</div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none; opacity: 0;"></div></div>
  

</body></html>